<h1>コンジット

<p>
  コンジットはストリーミングデータでの問題を解決する。
  Haskell は lazy に処理を行なう言語だ。
  lazy であるため、大量のデータをすべてメモリ上に置くことなく処理することができる。
  しかし、I/O の絡んでいる部分でそうするためには、lazy I/O を使わなければならない。
  lazy I/O の良くない点は、非決定的であることだ。つまり、リソースが解放されるタイミングを保証することができないのだ。
  小さなアプリケーションではそれで構わないかもしれない。
  しかし高負荷のサーバでは、ファイルハンドルのような希少なリソースはすぐに尽きてしまうことになるだろう。

<p>
  コンジットは、決定的リソースハンドリングでありながらも、大量のストリーミングデータを処理することができる。
  そして、ファイル、ソケット、メモリからやってくるデータストリームに対して統一的なインターフェースを提供する。
  これを ResourceT と組み合わせれば、安全にリソースを確保することができる。
  なぜなら、リソースを確保した後に例外が発生したとしても、正しくリソースが解放されることが分かっているからである。

<h2>５分で分かるコンジット

<p>
  いきなりコンジットの低レベルの仕組みを理解しようとするのはやめた方がいい。
  おそらくはほとんど頭に入らないだろう。
  まずはこの高レベル部分のサンプルから始めてみることを勧める。
  このサンプルの詳細が魔法みたいに見えたとしても気にしなくて構わない。
  これはすべて後に説明する。
  まずは専門用語の説明からしよう。

<dl>
  <dt>Source
  <dd>
    データの生産者。
    このデータは、ファイルになったり、ソケットだったり、メモリ上のリストだったりする。
    データを取り出すために、コンジットは source から pull する。 

<dl>
  <dt>Sink
  <dd>
    データの消費者。
    基本的な例は、sum 関数（与えられた数字のストリームを足し合わせる）や、ファイルの sink（ファイルへ不完全なバイトを書き込む）や、ソケットの sink（ソケットへ不完全なバイトを送信する）である。
    コンジットはデータを sink へ push する。
    sink の処理が終わった（詳細は後で説明する）とき、何らかの結果を１つだけ返す。 

<dl>
  <dt>Conduit
  <dd>
    データの変換。
    最も簡単なサンプルは map 関数だが、他にも多数存在する。
    sink と同様、コンジットは conduit へデータを push する。
    しかし conduit は、終了時に１つの値を返すのではなく、push されるたびに複数の値を返すことができる。  

<dl>
  <dt>Fuse
  <dd>
    conduit と source は、<code>$=</code> 演算子を使って混ぜ合わせる（Fuse）ことができる。そして fuse した結果は、新しい source として機能する。
    例えば、ファイルからバイトデータを読む source と、バイトデータをデコードして Text にする conduit があったとする。
    これらを fuse した場合、ファイルから Text を読む新しい source になる。
    同様に、conduit と sink を <code>=$</code> 演算子をつかって fuse することもできる。結果は新しい sink になる。
    そして conduit と conduit を <code>=$=</code> 演算子をつかって fuse することもできる。結果は新しい conduit になる。

<dl>
  <dt>Connect
  <dd>
    <code>$$</code> 演算子を使うことで、source と sink を繋げる（Connect）ことができるようになる。
    そうすると、コンジットは source からデータを pull し、sink へデータを push する。
    これは source か sink のどちらかが"done"になるまで続く。

<p>
  続いて、コンジットのサンプルを見てみよう。

<pre>#{code1}
