<h1>認証と認可

<p>
  認証（Authentication）と認可（Authorization）はよく似ているが、それらは全く別の概念だ。
  前者はユーザを識別する処理で、後者はユーザによってアクセス権が設定されているかを確認する処理だ。
  両者は単に認証（auth）と呼ばれることがあるため、これらの概念は混同されがちだ。

<p>
  Yesod はデフォルトで、OpenID, BrowserID, OAuth といったサードパーティによる認証をサポートしている。
  これらはユーザの信用情報（credential）を検証する外部のシステムである。Yesod アプリケーションは、この外部のシステムによる検証結果を信用して認証を行なう。
  さらに Yesod は、ユーザ名/パスワードの組み合わせや、メール/パスワードといった組み合わせによる認証もサポートしている。
  前者の方法は、ユーザにとっても、実装者にとっても簡単な保証しか行なわない。つまり、パスワードヒントは無いし、十分なセキュリティが担保されているわけでもない。
  後者の方法は、開発者がもっと細かく制御できるようになっている。

<p>
  認可においては、Yesod にはアドバンテージがある。
  Yesod には REST と型安全 URL があるため、シンプルかつ宣言的に作ることができる。
  さらに、認可のコードはすべて Haskell で書かれているため、言語の柔軟性を生かして、やりたいことを簡単に実現することができる。

<p>
  この章では、Yesod で認証と認可の書き方と、認証オプションの違いによるトレードオフについて議論する。

<h2>概要

<p>
  <a href="http://hackage.haskell.org/package/yesod-auth">yesod-auth
  \ パッケージは、様々な認証プラグインについて、統合されたインターフェースを提供している。
  これを使うために必要なバックエンドは、ユーザを一意に識別することができる文字列だけである。
  例えば OpenID では実際の OpenID である。BrowserID ではメールアドレスである。
  HashDB （パスワードをハッシュ化してデータベースに格納するプラグイン）ではユーザ名である。

<p>
  それぞれの認証プラグインは、それ自身がログイン機能を提供している。
  例えば外部サイトのパッシングトークン経由での認証や、メール/パスワードフォーム経由での認証などである。
  ログインが成功した後、認証プラグインはセッションに<code>AuthId</code>の値をセットする。
  この<code>AuthId</code>は通常、Persistent ID である。これはユーザをトラッキングし続けるために使われる。

<p>
  あるユーザの<code>AuthId</code>を取得する関数はいくつかある。
  最も一般的なのは、<code>maybeAuthId</code>, <code>requireAuthId</code>, <code>maybeAuth</code>, <code>requireAuth</code> である。
  require〜 系の関数は、ユーザがログインしていない場合にはログインページへとリダイレクトする。
  また、後ろ２つの 〜Auth 系の関数は、ID だけでなく、エンティティも取得する。

<p>
  セッションは、<code>AuthId</code> のセッション情報をストレージに格納するところから全てが始まる。
  セッション情報は HMAC で暗号化し、クライアントのクッキーに保存する。
  このとき、クライアントのクッキーは設定された時間が過ぎると自動的にタイムアウトするようになっている。
  また、セッション情報はサーバーサイドで保持していないため、ログアウトするには単にクッキーからセッション情報を削除するだけでいい。
  つまり、もしユーザが古いクッキーの値を再利用しているなら、セッションはまだ有効であるということだ。

<p>
  一方で、認可は <code>Yesod</code> 型クラスのいくつかのメソッドを使って操作する。
  これらのメソッドは、全てのリクエストについて、アクセスを許可する/しない、あるいはユーザ認証が必要かどうかを決める。
  デフォルトでは、全てのリクエストについてアクセスを許可するようになっている。
  また、型クラスのメソッドを使わなくても、個々の関数で <code>requireAuth</code> 系を呼び出してアドホックに認可を実装するという方法もある。
  しかしこれは、宣言的な認可システムのメリットを台無しにしてしまう。

<h2>認証する

<p>では認証のサンプルを見てみよう。

<pre>#{code1}

<p>
  まずはルートの宣言から見ていこう。
  最初の行では標準的なトップページを宣言している。
  次の行では、認証のためのサブサイトを宣言している。
  以前に説明したように、サブサイトの宣言では、サブサイトのパス、ルート名、サブサイト名、サブサイトを取得する関数を渡す必要がある。
  つまり、

<pre>/auth AuthR Auth getAuth

<p>
  この行は <code>getAuth :: MyAuthSite -> Auth</code> であるような関数が必要だということが分かる。
  この <code>getAuth</code> 関数はあらかじめ #
  <a href="http://hackage.haskell.org/package/yesod-auth">yesod-auth
  \ が提供しているため、自分で書く必要は無い。
  通常、サブサイトの動作を設定するには、そのサブサイト用のオブジェクトを作り、サブサイトを取得する関数で、そのオブジェクトを返す必要がある。
  しかし今回の場合、サブサイトのオブジェクトを作る必要は無く、<code>YesodAuth</code> という型クラスのインスタンスを作るだけで構わない。

<p>
  なぜサブサイトのオブジェクトを作るようにしなかったのか。
  それは、このサブサイトに与えたい設定は様々であり、レコード型でそれを記述するのが手間だったからである。
  また、<code>AuthId</code> という関連型を保持したいというのもある。これを実現するために型クラスを使うというのは、最も自然な解決策である。

<p>
  しかしそれなら、なぜ全てのサブサイトで型クラスを使うようにしなかったのだろうか。
  これは、型クラスの場合、１つのサイトに１つのインスタンスしか作れないからだ。
  この場合、２つ以上のルートから静的ファイルを転送するといったことができなくなってしまう。
  また、型クラスではなくオブジェクトを使えば、アプリケーションの初期化時にデータをロードするといった処理が簡単に書ける。
  そのため、オブジェクトを使う方が一般的である。

<p>YesodAuth インスタンスは、６つの宣言を要求している。
<ul>
  <li>
    <code>AuthId
    は関連型である。これは、<code>maybeAuthId</code> や <code>requireAuthId</code> などでユーザがログインしたかどうかを問い合わせるときに使われる値である。
    ここでは単純に <code>Text</code> を <code>AuthId</code> にしている。
    email などでユーザを識別するようなケースは、この後で見ていく。
  <li>
    <code>getAuthId</code>
    は、<code>Creds</code>(credentials: 信用情報)から <code>AuthId</code> を返す関数だ。
    この <code>Creds</code> 型は、３つの情報を保持する。
    １番目はバックエンドで使われる認証プラグイン（今回の場合は BrowserID と GoogleEmail）、
    ２番目は識別子、
    ３番目はそれぞれのバックエンド固有の情報である。
    今回の場合、２番目の情報を取り出す<code>credsIdent</code>関数を使って<code>AuthId</code>（今回の場合は<code>Text</code>）を返している。
  <li>
    <code>loginDest
    には、ログインに成功した後に遷移するリダイレクト先のルートを指定する。
  <li>
    同様に、
    <code>logoutDest
    には、ログアウトした後に遷移するリダイレクト先のルートを指定する。
  <li>
    <code>authPlugins
    は、使用する認証用のバックエンドのリストを指定する。
    今回のサンプルでは、Mozzila の BrowserID システムを使った BrowserID バックエンドと、Google アカウントのメールアドレス使った Google Email バックエンドを指定している。
    これらのバックエンドは非常に使い勝手が良い。なぜなら、
    <li>
      これらはセットアップを必要としない。
      それに対して Facebook や OAuth バックエンドなどの場合は、信用情報のセットアップを行なう必要がある。
    <li>
      これらはユーザの識別子としてメールアドレスを使っている。
      メールアドレスは、多くのユーザが手軽に利用できる識別子である。
      それに対して OpenID バックエンドなどの場合は、ユーザの識別子として URL を使うことになる。
  <li>
    <code>authHttpManager
    は、HTTP 接続のマネージャを返す。
    多くの認証バックエンドは何度も HTTP 接続を行なうが、その際の接続を共有することで、接続に掛かるコストを回避するために使われる。
    つまり HTTP 接続を行なわないバックエンドを利用する場合は必要ない。
    その場合は単に<code>authHttpManager = error "authHttpManager"</code>などと記述すれば良い。

<p>
  今回の<code>RootR</code>ハンドラは、ログイン/ログアウトページへの単純なリンクを表示する。
  どちらのリンクが表示されるかは、現在ログインしているかどうかによって変わる。
  サブサイトのリンクの構築方法にも注目して欲しい。
  最初にサブサイトのルート（<code>AuthR</code>）を指定し、それに続いてサブサイトの各ページ（<code>LoginR</code>や<code>LogoutR</code>）を指定する。
<p>
  このページは、ユーザ視点で見ると、以下の様なログインプロセスになる。

<figure>
  <figcaption>初期状態のホームページ
  <img src=@{StaticR yesodbookjp_img_initial_screen}>

<figure>
  <figcaption>BrowserID でのログイン画面
  <img src=@{StaticR yesodbookjp_img_login_with_browserid}>

<figure>
  <figcaption>ログイン後のホームページ
  <img src=@{StaticR yesodbookjp_img_after_login}>

<h2>メール

<p>
  認証は、多くの場合はサードパーティ製のメール認証で十分である。
  しかし時々、第三者による認証ではなく、自身のサイト上でユーザ認証を行いたいこともある。
  だが、スカフォードサイトは、このためのサンプルを用意していない。なぜなら、

<ul>
  <li>
    セキュアにパスワードを受け渡すには、SSL 上でやりとりする必要がある。
    しかし SSL を用意するユーザは稀である。
  <li>
    メールのバックエンドはパスワードにソルトを付けてハッシュ化しているが、データベース全体の情報が漏れた場合には無力である。
    また、Yesod ユーザがこの方法が正しいと思い込んでしてしまうことは避けたいという理由もある。
  <li>
    メールを送信するためには、そのためのシステムを動かしている必要がある。
    しかし最近の Web サービスはスパム対策を行なっていない。

<p>
  以下のサンプルは、システム組み込みの sendmail 機能を使う。
  メールサーバーを動かすことによる諸問題を回避したければ、Amazon SES などのサービスを利用するのもいいだろう。
  <a href="http://hackage.haskell.org/package/mime-mail-ses">mime-mail-ses
  \ パッケージは、Amazon SES を利用したメール送信の機能を持っている。
  このパッケージを使えば、以下の sendmail を使ったサンプルを簡単に Amazon SES を使うように置き換えられる。
  このパッケージは #
  <a href="www.haskellers.com">haskellers.com
  \ で利用されている。

<p>
  Yesod 組み込みのメール認証バックエンドは、少しのセットアップコードで、DB にパスワードをセキュアに格納したり、ユーザに異なるメールを送信したり、アカウントのベリファイや、パスワードリマインドなどができるようになる。

<p>
  ではメール認証を提供するサイトを見てみよう。
  パスワードは SQLite に格納する。

<pre>#{code2}

<h2>認可

<p>
  一度ユーザを認証してしまえば、認可のリクエストを受けた際に、そのユーザの信用情報を利用することができるようになる。
  Yesod の認可はシンプルで、そして宣言的である。
  つまり、Yesod 型クラスの <code>authRoute</code> と <code>isAuthorized</code> メソッドを追加するだけで認可ができるようになる。
  ではサンプルを見てみよう。

<pre>#{code3}

<p>
  <code>authRoute
  \ はログインページである必要がある。ほとんどの場合は
  <code>AuthR LoginR
  \ で構わない。
  <code>isAuthorized
  \ は２つの引数を取る。
  アクセスしてきたページのルートと、"書き込み" のリクエストであるかどうかの Bool 値だ。
  書き込みリクエストであるかどうかは、
  <code>isWriteRequest
  \ メソッドを使うことで、その意味を変更することができる。
  だが、このメソッドを使って常識に囚われない革新的な Web サーバーを作ったとしても、RESTful な原則は守るべきだろう。
  つまり、<code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>TRACE</code> 以外は書き込みリクエストにするべきだ。

<p>
  <code>isAuthorized
  \ で便利なのは、この関数が #
  <code>Handler
  \ を返すことだ。
  つまりこれは、以下のことを意味する。

<ul>
  <li>ファイルシステムにアクセスできる（普通に IO が使える）
  <li>データベースから値を検索することができる
  <li>欲しいセッションやリクエストの情報を取得することができる

<p>
  これらのテクニックを使うことで、好きな認可のシステムをスマートに開発できるようになるだろう。
  あるいは、既存のシステムと同等のものが作れるようになるだろう。

<h2>結論

<p>
  この章は、基本的なユーザ認証と、どのように組み込みの認可を行うのかの基本について説明した。
  認証と認可には複雑なコンセプトと多くの手法があるが、Yesod はビルディングブロックを提供している。
  このビルディングブロックは、必要であれば自身でカスタマイズして作ることもできる。
