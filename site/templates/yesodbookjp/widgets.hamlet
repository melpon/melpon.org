<h1>ウィジェット

<p>
  Web 開発で難しいことの１つは、クライアント側で HTML, CSS, JavaScript を使い分けなければならないということだ。
  これらは同一ページ上の異なる場所に配置する必要がある。CSS なら head の style タグの中に、JavaScript なら head の script タグの中に、そしてコンテンツは body の中に。
  実際のところ、これは構造（HTML）、スタイル（CSS）、ロジック（JavaScript）を分離することができるため、１つのページを構築するだけなら、非常にうまく分けられる。
  しかしこれは、複数のページで同じコード片を使いたいと思ったときに、頭を悩ませることになる。
  ウィジェットは、この問題に対する Yesod の解決策だ。

<p>
  ４つのテンプレート言語、Hamlet, Cassius, Lucius, Julius は、単に出力を生成するだけのツールだ。ウィジェットは、それらをシームレスに動作させるための接着剤として機能する。

<h2>概要

<pre>#{code1}

<p>これは以下のような HTML を生成する（インデント済み）。

<pre>#{code2}

<h2>ウィジェットとは

<p>
  表面的なレベルで言えば、HTML ドキュメントは単にネストされたタグの集まりでしかない。
  多くの HTML 生成ツールは、このタグの構造を直接埋め込んで生成するという方法を取っている。
  しかし、例えばナビゲーションバーのコンポーネントを作る場合を考えてみよう。
  これは、適当に関数を呼び出すだけでナビゲーションバーが挿入されて欲しいと思うだろう。つまり、コンポーネントは "プラグアンドプレイ" であって欲しいのだ。

<p>
  しかしこれは、単にタグを埋め込むだけでは難しい。
  ナビゲーションバーはおそらく、１つの HTML と、いくつかの CSS と JavaScript で構成されている。
  そのため、最低でも３つのセットが正しく HTML に埋め込まれているかを確認しなければならないのだ。

<p>
  ウィジェットはこれとは異なる方法を用いる。
  ウィジェットは、１つのページをコンポーネントの集まりとして見る。
  例を挙げると、以下のようなものである。

<ul>
  <li>タイトル
  <li>外部スタイルシート
  <li>外部スクリプト
  <li>CSS 宣言
  <li>JavaScript コード
  <li>任意の &lt;head&gt; のコンテンツ
  <li>任意の &lt;body&gt; のコンテンツ
  <li>及び、これらの組み合わせ

<p>
  これらの組み合わせを利用することで、ナビゲーションバーのような複雑なコンポーネントを作りあげることができる。そしてそれは "プラグアンドプレイ" として、簡単にページ内へ組み込むことができる。

<p>
  また、これらの組み合わせをコンポーネントとしていくつも用意した場合、問題になるのは、同じ内容の重複だ。
  例えばタイトルは１度しか設定してはならないし、外部スクリプトやスタイルシートは、同じURLなら再度挿入する必要は無い。
  ウィジェットの役割は、これらを適切に組み合わせられるようにすることである。
  つまり、１回目以降のタイトルの設定を無視したり、外部スクリプトやスタイルシートから重複を除けたり、head や body のコンテンツを繋ぎ合わせるといった作業を行なう。

<h2>ウィジェットの構築

<p>
  ウィジェットを作る方法はいくつかある。最も一般的な方法は、ToWidget 型クラスと、そのメソッドである toWidget を使うことだ。
  これは Shakespeare テンプレートを直接ウィジェットに変換する。
  つまり Hamlet コードは body に、Julius スクリプトは head の script の中に、Cassius と Lucius は head の style タグの中に埋め込まれることになる。

<aside>
  実際には、デフォルトの動作をオーバーライドし、スクリプトやスタイルのコードを別々のファイルに出力するとができる。
  スカフォードサイトはこれを自動的に提供する。
  非同期なスクリプトのロードによる書き換えについては{{Yesod型クラスの章}}で説明する。
  これは非同期にスクリプトのロードを行い、body の末尾にスクリプトを配置する。

<p>
  ただ、head に入れるべきか body に入れるべきか、自動的に判断できない場合がある。
  例えば &lt;meta&gt; タグは head と body のどちらに現れても構わない。
  あるいは JavaScript は、head ではなく body に現れても構わない。
  こういった問題のために、Yesod は更に ToWidgetHead と ToWidgetBody の２つの型クラスを提供している。
  これらは名前通りの動作を行なう。

<aside>
  Lucius と Cassius は、ToWidgetBody がインスタンス化されていない。これは body 内に style タグを置くことができないからである。

<p>
  また、特定の種類のウィジェットを作るための関数が多数存在する。

<dl>
  <dt>setTitle
  <dd>title タグの HTML を書き換える
<dl>
  <dt>addCassiusMedia
  <dt>addLuciusMedia
  <dd>
    toWidget と同じように動作するが、メディアの種類を追加で引数に取る。これは印刷用のスタイルシートを作る場合などに利用することができる。（印刷用のスタイルシートを作るためには
    <code>&lt;link rel="stylesheet" href="print.css" type="text/css" media="print" /&gt;
    などのように media を指定する必要がある。）
<dl>
  <dt>addStylesheet
  <dd>&lt;link&gt; タグを使って外部スタイルシートを読み込む。これは型安全 URL で指定する。
<dl>
  <dt>addStylesheetRemote
  <dd>addStylesheet と同じだが、通常の URL を取る。Google の jQuery UI の CSS のような、CDN でホストされているファイルを参照する場合などで利用する。
<dl>
  <dt>addScript
  <dd>&lt;script&gt; タグを使って外部スクリプトを読み込む。これは型安全 URL で指定する。
<dl>
  <dt>addScriptRemote
  <dd>addScript と同じだが、通常の URL を取る。Google の jQuery のような、CDN でホストされているファイルを参照する場合などで利用する。

<h2>ウィジェットの組み合わせ

<p>
  ウィジェットの目的は、結合可能性（composability）を高めることだ。
  ウィジェットは、小さな HTML, CSS, JavaScript のピースを組み合わせ、複雑なものを作ることができる。そしてその複雑なものを組み合わせ、ページを作っていく。
  これは Widget モナドのインスタンスを使うことで自然に記述することができる。
  つまりそれぞれのピースを do 記法で記述することができる。

<dl>
  <dt>ウィジェットの組み合わせ
  <dd>
    <pre>#{code3}

<aside>
  これは Monoid インスタンスとして使うこともできる。つまり mconcat や Writer モナドを使って記述することもできる。
  ただ、do 記法が一番自然だと感じるだろう。

<h2>IDの生成

<p>
  本当に再利用できるコードにしたい場合、名前の衝突についても考慮する必要がある。
  例えばウィジェットになっている２つのライブラリがあるとする。これらのライブラリのスタイルが、両方とも "foo" というクラス名を使っていた場合、名前が衝突してしまう。
  これをできる限り回避するために、newIdent 関数がある。
  この関数は、あるハンドラ内でユニークな文字列を自動的に生成する。

<dl>
  <dt>newIdentの利用
  <dd>
    <pre>#{code4}

<aside>
  ここで使っている lift というのは何だろうか。
  これは、Handler レイヤから Widget レイヤに変換するための関数である。
  Widget は Handler の上に座すモナド変換子であるため、lift 関数によって変換することができる。
  lift を使って Widget モナド変換子に変換することで、様々なアクションを行なうことができるようになる。
  例えばウィジェット内でデータベースへのクエリを投げたりすることができるようになる。
  詳細は{{Yesodのモナド}}で説明する。

<h2>whamlet

<p>
  Hamlet でフッターを組み込みたい場合、以下のように書くことができる。

<pre>#{code5}

<p>
  これは正しく動作する。
  しかし、もしこのフッターに何らかのスタイルを加えたいと思った場合はどうすればいいだろうか。
  これは単純に考えれば、Hamletテンプレートではなくfooterをウィジェットにすることで解決できそうに感じる。

<pre>#{code6}

<p>
  しかしこれは動作しない。Hamlet テンプレートの埋め込み補間は、Hamlet テンプレートしか組み込めない。つまりウィジェットを組み込むことができないのだ。
  この場合、whamlet を利用することになる。これは通常のHamletと同じように変数補間（<code>&#35;{...}</code>）や URL 補間（<code>&#64;{...}</code>）を利用することができる。
  ただし埋め込み補間（<code>&#94;{...}</code>）は、HamletではなくWidgetを取るようになる。そして最終的な結果はWidgetになる。
  これは以下のように利用する。

<pre>#{code7}

<p>
  hamletFile に対する、whamletFile 関数もある。

<aside>
  スカフォードサイトでは、widgetFile という、もっと便利な関数を使っている。
  これは Lucius, Cassius, Julius ファイルも自動的にインクルードする。
  詳細については {{スカフォードの章}} で説明する。

<h3>型

<p>
  先ほどの例は、わざと型シグネチャを書かなかった。これは少し複雑な話になってしまうからだ。
  技術的な詳細を以下に記述しているが、理解できなくても問題は無い。
  大抵は、Widgetという型シノニムを使えば解決するということだけを覚えておけばいい。

<p>
  実のところ、Widgetという型はYesodには定義されていない。
  その正確な意味がサイト毎に変わるからだ。
  代わりに、<code>GWidget sub master a</code> という、一般化された型が定義されている。
  Yesod のベースの型が <code>MyCoolApp</code> だとすれば、<code>type Widget = GWidget MyCoolApp MyCoolApp ()</code> という型が、スカフォードサイトによって自動的に定義される。

<p>
  sub/master というのは何をするためのものだろうか。
  これは、CRUDのような再利用可能なコードを書き、他のYesodアプリケーションに組み込まれる際に重要になる。この場合、サブサイトとマスターサイトの両方の情報を保持しておく必要がある。
  例えば一番簡単な例として、型安全 URL がある。
  Yesod のマスターサイトは、適切にURLレンダリングを行なうために、CRUDサブサイトがどんなルートを取るのか、マスターサイトのルートをどのように変更すればいいのかを知っている必要がある。

<p>
  ただし、サブサイト/マスターサイトの違いは、サブサイトを作っているときだけ重要になる。
  通常の処理を書いているときは、サブサイトとマスターサイトは同じものになる。
  これが一般的であるため、スカフォードは上記のような Widget 型を用意しているのだ。
  先程の例に型をつけるなら、最初に書いたとおり、以下のようにするだけでいい。

<pre>#{code8}

<aside>
  <p>
    newIdent を説明している箇所で、Widget はモナド変換子であると言っていたが、実のところ、そうではない。
    古いバージョンのYesodでは、実際にモナド変換子だった。
    しかしこれは、エラーが発生した際に、そのエラーを理解するのが難しいエラーメッセージになってしまったのだ。
    そのため、GWidget は現在、モナド変換子のエッセンスを隠した、newtype のラッパーになっている。
  <p>
    しかしそうしてしまうと、今度は lift 関数が使えなくなってしまう。
    そのため Yesod は、MonadTrans インスタンスと、GWidget のような特殊な newtype ラッパーの両方で動作する、もっと一般化した lift 関数を定義した。
    これによって、GWidget は分かりやすいエラーメッセージを表示しつつ、lift 関数を使えるようになったのである。

<p>
  Widget, GWidget の関係と同様、Handler, GHandler も同じような関係である。

<h2>ウィジェットの利用

<p>
  Widget をユーザで扱うにはどうすればいいだろうか。Widget は、いつか HTML のデータを生成し、レスポンスを返さなければならない。
  通常、このために利用するのは defaultLayout だ。これは基本的に、<code>Widget -&gt; Handler RepHtml</code> という型シグネチャである（"基本的に"と記述したのは、GHandler の話になるからだ）。
  RepHtml の中には、レスポンスのための生の HTML が入っている。

<p>
  実際は、defaultLayout は Yesod 型クラスのメソッドである。
  そのため、これをそれぞれのアプリケーションでオーバーライドすることができる。
  この実装をオーバーライドするとき、どのようにして Widget をアンラップすればいいだろうか。
  これには widgetToPageContent を使う。この関数の型シグネチャを見てみよう。

<pre>#{code9}

<p>
  この関数は、ウィジェットを、title, head, body のそれぞれの HTML に変換する関数である。
  あとは、この PageContent を Hamlet テンプレートの埋め込み補間を使って設定し、そのデータを hamletToRepHtml で RepHtml に変換するだけだ。

<dl>
  <dt>widgetToPageContentの利用
  <dd>
    <pre>#{code10}

<aside>
  ここでは、Widget, Handler と書かず、GWidget, GHandler と書いている。
  これは、defaultLayout はサブサイトからも呼ばれるメソッドだからである。
  そのため、ここでは型をフレキシブルにしておく必要がある。

<p>
  あと１つだけ問題がある。style タグだ。
  以下のような問題がある。

<ul>
  <li>Lucius や Cassius と違い、これはコンパイル時にチェックされない。
  <li>ここのサンプルはシンプルだが、もっと複雑な場合は文字エスケープの問題を起こしてしまう可能性がある。
  <li>
    myLayout が出力する RepHtml には、style タグが２つ含まれる可能性がある。
    もし pageHead にスタイルの情報があった場合、myLayout の Hamlet 内で直接指定しているのと合わせて２つ含まれてしまうことになる。

<p>
  これはウィジェットを Hamlet に変換した後にスタイルを適用しようとしているためである。
  この問題を解決するためには、widgetToPageContent を呼び出すより前に、ウィジェットにスタイルを適用してしまえばいい。

<dl>
  <dt>最後のWidgetの調整
  <dd>
    <pre>#{code11}

<h2>要約

<p>
  各ページの基本的なビルディングブロックはウィジェットである。
  HTML, CSS, JavaScript のテンプレートは、toWidget 関数でウィジェットに変換することができる。
  また、do 記法を使うことで、個々のウィジェットを組み合わせ、さらにそれらのウィジェットを組み合わせ、最終的にページを構築することができる。

<p>
  ウィジェットのアンラップは通常、defaultLayout 関数を使う。
  これは全てのページを統一するために使うことができる。
