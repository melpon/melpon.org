<h1>セッション

<p>
  HTTP は状態を持たない。
  これはいくつかの場面では欠点となるが、同時に RESTful な Web 開発をする者にとっては利点にもなる。
  状態を持たないようにすると、アプリケーションを簡単にスケールさせることができるようになったり、自動的にキャッシュを行うことができるようになったり、他にも様々な利点がある。
  また、状態を持たないというのは、Haskell の考え方とよく合う。

<p>
  RESTful なアプリケーションは、クライアントの状態を格納することをできるだけ回避するべきだ。
  しかし回避できない場合もある。
  例えばショッピングカードのような機能などである。
  あるいは、正しいログイン処理といった、日常的に発生する対話は、セッションを適切に使うことでより良くすることができる。

<p>
  この章では、Yesod がどうやってセッションデータを格納し、アクセスするのかと、セッションを作るためのヘルパ関数を説明する。

<h2>クライアントセッション

<p>
  Yesod から最も早く独立したパッケージの１つは、
  <a href="http://hackage.haskell.org/package/clientsession">clientsession
  \ だった。
  このパッケージは、データに暗号化と署名をした上で、クライアントのクッキーに格納する機能を提供している。
  暗号化によってデータ解析されることを防ぎ、署名によってセッションハイジャックや不正アクセスされることを防ぐ。

<p>
  効率の観点から見ると、これは良くないアイデアだと思うかもしれない。
  なぜならこれは、すべてのリクエストに対して必要なデータを送受信しなければならないからだ。
  しかし実際には、効率を考慮したとしてもクライアントセッションは有用である。
  なぜなら、
  <li>
    サーバーサイドのデータベース検索が一切無い
  <li>
    それぞれのリクエストは、レスポンスを返すために必要な情報をすべて含んでいる。
    これはつまり、簡単に横にスケールさせることができるということである。
  <li>
    必要であれば、オーバーヘッドを回避することもできる。
    つまり、静的コンテンツなどの、セッションクッキーの情報が必要でないデータなら、クッキーを必要としない、別のドメインからサーブするという方法もある。

<p>
  ただし、セッションにメガバイト単位の情報を格納するのは良くない方法である。
  通常、セッション用のデータだけでこのようなサイズが必要になることは無いが、
  もし本当にそのサイズの情報が必要になったのなら、セッションにはルックアップキーのみを格納し、実際のデータはデータベースに格納するのがいいだろう。

<p>
  クライアントセッションのやりとりは、ほとんどが Yesod 内部で処理されている。
  開発者はほんの少しだけ振る舞いを調整することができる。

<h2>セッション制御

<p>
  Yesod には、セッションの振る舞いを制御するための関数が１つだけ存在している。
  それは #
  <a href="http://hackage.haskell.org/packages/archive/yesod-core/latest/doc/html/Yesod-Core.html#v:makeSessionBackend">makeSessionBackend
  \ である。
  デフォルトでは、ローカルファイルの暗号化キーを使って、120 秒でタイムアウトするという設定を返す。
  これをオーバーライドして Nothing を返すようにした場合、セッションは無効になる。

<p>
  なぜセッションを無効にするのか。
  これは、セッションにはパフォーマンス上のオーバーヘッドがあるからだ。
  通常、このオーバーヘッドは小さく、特にデータベースと比較すればほとんど無視できる程度のものだ。
  しかし、簡単な処理を大量に捌くような場合には、このオーバーヘッドは無視できないものになる。
  こういった場合には、セッションを無効にすることも検討するべきだろう。
  ただし、セッションを無効にするのは注意が必要である。
  これは CSRF プロテクションといった機能も無効にしてしまうからである。

<p>
  セッション機能を使う場合、
  <code>makeSessionBackend
  \ 関数で #
  <a href="http://hackage.haskell.org/packages/archive/yesod-core/latest/doc/html/Yesod-Core.html#v:clientSessionBackend">clientSessionBackend
  \ を使って #
  <code>SessionBackend
  \ を返すことになるだろう。
  <code>clientSessionBackend
  \ は２つの引数を取る。１つはクッキーの暗号化に使うキーで、もう１つはタイムアウトの時間である。

<p>
  暗号化キーは、デフォルトでは
  <a href="http://hackage.haskell.org/packages/archive/clientsession/latest/doc/html/Web-ClientSession.html#v:defaultKeyFile">defaultKeyFile
  \ が使われる。
  この関数はローカルにファイルを作るため、データベースがシャットダウンしていたとしてもセッションは継続する。
  また、ファイルが存在していない場合にはランダムデータで自動的に暗号化キーを作る。

<p>
  タイムアウトは、セッションがアクティブになっている時間を分単位で指定する。
  デフォルトでは 120 分（2時間）だ。
  セッションクッキーに格納されているこの値が書き換えられるタイミングは２つある。
  １つはクッキー自身によって期限切れを確認したとき。
  もう１つは、Yesod 側で期限切れを確認したときである。
  つまりセッションの中には、自身が期限切れになる時間が含まれている。
  そして Yesod がその値を読み、セッションが期限切れだった場合には、Yesod は単にそのセッションの値を無視する。

<p>
  Yesod がクライアントにレスポンスを送るとき、毎回新しいセッションクッキーも一緒に送っている。
  この方法なら、クライアントがセッションクッキーの値を更新するのに失敗したとしても、ブラウザを開きっぱなしであればセッションはタイムアウトにならない。

<h2>セッション操作

<p>
  多くのフレームワークと同様、Yesod のセッションはキーバリューストアになっている。
  セッションの基本的な操作は３つの関数だけである。
  <code>lookupSession
  \ は（存在すれば）キーから値を取得し、
  <code>setSession
  \ はキーと値をセットし、
  <code>deleteSession
  \ はキーから値を削除する。

<pre>#{code1}

<h2>メッセージ

<p>
  セッションの使い方の１つとして、メッセージがある。
  これは Web 開発での共通の問題を解決する。
  その問題とは、ユーザが POST リクエストを投げ、Web アプリで処理し、そして Web アプリは新しいページヘのリダイレクトと成功メッセージを同時に表示したい、というものである。
  これは Post/Redirect/Get として知られている問題である。

<p>
  Yesod は、これを２つの関数を使うことで簡単に解決する。
  <code>setMessage
  \ はセッションの中に値を格納し、
  <code>getMessage
  \ はセッションに格納された値を読み、その値を削除する。
  値を削除するため、同じメッセージが２回表示されてしまうというアクシデントは起こらない。

<p>
  <code>getMessage
  \ は #
  <code>defaultLayout
  \ 関数内で使用することを推奨する。
  なぜなら、こうすることでハンドラごとに <code>getMessage</code> を呼び出したかどうか気にする必要がなくなるからだ。
  また、defaultLayout ならどのページでも反映されるため、すぐにユーザに結果を表示することができる。

<pre>#{code2}

<figure>
  <figcaption>初期状態、メッセージ無し
  <img src=@{StaticR yesodbookjp_img_messages_1}>

<figure>
  <figcaption>メッセージを追加
  <img src=@{StaticR yesodbookjp_img_messages_2}>

<figure>
  <figcaption>Submit ボタンを押した後。メッセージがトップに現れる。
  <img src=@{StaticR yesodbookjp_img_messages_3}>

<figure>
  <figcaption>更新するとそのメッセージは消える
  <img src=@{StaticR yesodbookjp_img_messages_4}>

<h2>最終転送先

<p>
  <a href="">yesod-auth
  \ の内部は、「ホラー映画と混同してはならない」というコンセプトで作られている。
  ユーザが認証を必要とするページにアクセスしたとする。
  このとき、もしユーザがログインしていないなら、ログインページにリダイレクトする必要がある。
  そして、良いデザインの Web アプリは、ログイン後、最初にアクセスしようとしたページヘリダイレクトする。
  このような仕組みを "最終転送先" (ultimate destination) と呼んでいる。

<p>
  <code>redirectUltDest
  \ は、ユーザに最終転送先を送り、セッションからその最終転送先を削除する。
  転送先が設定されていない場合は、デフォルトの転送先を使う。
  転送先の情報をセッションに設定する方法は３つある。
  <li>
    <code>setUltDest
    \ は、引数で与えられた URL を設定する。
  <li>
    <code>setUltDestCurrent
    \ は、現在リクエストされている URL を設定する。
  <li>
    <code>setUltDestReferer
    \ は、
    <code>Referer
    \ ヘッダの URL を設定する。

<p>
  簡単なサンプルを見てみよう。
  これは、あるページで、セッションに格納されているユーザ名を表示する。
  ただし、セッションにユーザ名が格納されていなければ、このページを最終転送先として設定し、名前を設定するための別のページヘリダイレクトする。
  そしてユーザ名を入力した後、最終転送先を使って最初のページへリダイレクトする。

<pre>#{code3}

<h2>要約

<p>
  セッションは、状態を持てないという HTTP の制限を解決する一番の方法だ。
  しかし、これを逃げ道にしてはならない。
  つまり、状態を持てないという制限は良いことであり、可能な限りこれを使うべきである。

<p>
  Yesod のセッションはシンプルである。
  これは単純なキーバリューストアになっていて、よくあるケースについては便利な関数が提供されている。
  これらを適切に使ったなら、セッションは Web 開発を陰ながら支える存在になるだろう。
